# telegraf ambient data to influxdb
[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "5s"
  flush_jitter = "0s"
  precision = ""
  debug = true
  quiet = false
  logfile = ""
  # hostname = "$HOSTNAME"
  hostname = "telegraf"
  # set to true MW
  # omit_hostname = false
  omit_hostname = true

[[outputs.influxdb_v2]]	
  ## The URLs of the InfluxDB cluster nodes.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the 
  ## urls will be written to each interval.
  urls = ["http://iots_2025s-influxdb2-1:8086"]

  ## Token for authentication.
  token = "vS0HVFGmuus2bTK1HwvYBwBiBzTyCvCaSsmzJbBTk2IZJsRiacPEScUFfUxttU1UP0jPMIV3l7jOdyGjOkggUg=="

  ## Organization is the name of the organization you wish to write to; must exist.
  organization = "Lab University"

  ## Destination bucket to write into.
  # bucket = "Test-bucket-for-IoT-pipeline"
  bucket = "iots_2025s_test_data"

# [[inputs.http_response]]
#   ## List of urls to query.
#   urls = ["http://www.lab.fi","http://www.hamk.fi", "http://www.xamk.fi"]
#   interval = "30s"

#   ## Set response_timeout (default 5 seconds)
#   response_timeout = "5s"

#   ## HTTP Request Method
#   method = "HEAD"

#   ## Whether to follow redirects from the server (defaults to false)
#   follow_redirects = true

#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"

#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"

#   ## Optional HTTP Request Body
#   # body = '''
#   # {'fake':'data'}
#   # '''

#   ## Optional name of the field that will contain the body of the response.
#   ## By default it is set to an empty String indicating that the body's content won't be added
#   # response_body_field = ''

#   ## Maximum allowed HTTP response body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   ## If the response body size exceeds this limit a "body_read_error" will be raised
#   # response_body_max_size = "32MiB"

#   ## Optional substring or regex match in body of the response (case sensitive)
#   # response_string_match = "\"service_status\": \"up\""
#   # response_string_match = "ok"
#   # response_string_match = "\".*_status\".?:.?\"up\""

#   ## Expected response status code.
#   ## The status code of the response is compared to this value. If they match, the field
#   ## "response_status_code_match" will be 1, otherwise it will be 0. If the
#   ## expected status code is 0, the check is disabled and the field won't be added.
#   # response_status_code = 0

#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#   ## Use the given name as the SNI server name on each URL
#   # tls_server_name = ""

#   ## HTTP Request Headers (all values must be strings)
#   # [inputs.http_response.headers]
#   #   Host = "github.com"

#   ## Optional setting to map response http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will be added
#   ## If multiple instances of the http header are present, only the first value will be used
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}

#   ## Interface to use when dialing an address
#   # interface = "eth0"

[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  files = ["stdout", "/tmp/metrics.out"]

  ## Use batch serialization format instead of line based delimiting.  The
  ## batch format allows for the production of non line based output formats and
  ## may more efficiently encode and write metrics.
  # use_batch_format = false

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  rotation_interval = "1h"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  rotation_max_size = "1MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md

  ## The resolution to use for the metric timestamp.  Must be a duration string
  ## such as "1ns", "1us", "1ms", "10ms", "1s".  Durations are truncated to
  ## the power of 10 less than the specified units.
  # json_timestamp_units = "1s"
  

[[inputs.mqtt_consumer]]
  ## Broker URLs for the MQTT server or cluster.  To connect to multiple
  ## clusters or standalone servers, use a seperate plugin instance.
  ##   example: servers = ["tcp://localhost:1883"]
  ##            servers = ["ssl://localhost:1883"]
  ##            servers = ["ws://localhost:1883"]
  servers = ["tcp://iots_2025s-mosquitto-1:1883"]

  ## Topics that will be subscribed to.
  # "iots_2025/TT10/kitchen"
  # topics = [
  #   "telegraf/host01/cpu",
  #   "telegraf/+/mem",
  #   "sensors/#"
  # ]
  topics = [
    "iots_2025/Heinola/Forest_SE2"
  ]

  # chenage the default mqtt_consumer measurement name 
  #   name_override = "ambient-house"

  # json_string_fields = ["org", "value"]

  ## The message topic will be stored in a tag specified by this value.  If set
  ## to the empty string no topic tag will be created.
  # topic_tag = "topic"

  ## QoS policy for messages
  ##   0 = at most once
  ##   1 = at least once
  ##   2 = exactly once
  ##
  ## When using a QoS of 1 or 2, you should enable persistent_session to allow
  ## resuming unacknowledged messages.
  # qos = 0

  ## Connection timeout for initial connection in seconds
  # connection_timeout = "30s"

  ## Maximum messages to read from the broker that have not been written by an
  ## output.  For best throughput set based on the number of metrics within
  ## each message and the size of the output's metric_batch_size.
  ##
  ## For example, if each message from the queue contains 10 metrics and the
  ## output metric_batch_size is 1000, setting this to 100 will ensure that a
  ## full batch is collected and the write is triggered immediately without
  ## waiting until the next flush_interval.
  # max_undelivered_messages = 1000

  ## Persistent session disables clearing of the client session on connection.
  ## In order for this option to work you must also set client_id to identify
  ## the client.  To receive messages that arrived while the client is offline,
  ## also set the qos option to 1 or 2 and don't forget to also set the QoS when
  ## publishing.
  # persistent_session = false

  ## If unset, a random client ID will be generated.
  # client_id = ""

  ## Username and password to connect MQTT server.
  # username = "telegraf"
  # password = "metricsmetricsmetricsmetrics"

  ## Optional TLS Config
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## Data format to consume.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
  # data_format = "json"

  data_format = "json_v2"

  # data_format="value" 
  # data_type="float"

  # # Added by MW 20102022
  # # No need for topic parsing (but this works)
  [[inputs.mqtt_consumer.topic_parsing]]
    # topic org/addr/loc parsing to tags
    topic = "+/+/+"  # all topics 
    tags = "org/addr/loc"  

  [[inputs.mqtt_consumer.json_v2]]
      [[inputs.mqtt_consumer.json_v2.field]]
          path = "temperature"
          type = "float"
      [[inputs.mqtt_consumer.json_v2.field]]
          path = "pressure"
          type = "float"
      [[inputs.mqtt_consumer.json_v2.field]]
          path = "humidity"
          type = "float"
      [[inputs.mqtt_consumer.json_v2.tag]]
          path = "device"
    #   [[inputs.mqtt_consumer.json_v2.field]]
    #       path = "lightning"
    #       type = "float"
    #   [[inputs.mqtt_consumer.json_v2.field]]
    #       path = "co2"
    #       type = "float"

    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "zip"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "city"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "street"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "nbr"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "device"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "room"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "floor"
    #   [[inputs.mqtt_consumer.json_v2.tag]]
    #       path = "category"
      # [[inputs.mqtt_consumer.json_v2.tag]]
      #     path = "loc"
      #     rename = "location"
          # type = "string"
      # [[inputs.mqtt_consumer.json_v2.field]]
      #     path = "loc"
      #     rename = "location"
      #     type = "float"


